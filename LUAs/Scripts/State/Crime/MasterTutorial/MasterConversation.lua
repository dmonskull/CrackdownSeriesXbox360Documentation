----------------------------------------------------------------------
-- Name: MasterConversation State
--	Description: Talk to another character, then wait for a reply
-- Owner: Nathan
-- (c) 2005 Real Time Worlds
----------------------------------------------------------------------

require "System\\State"
require "State\\NPC\\Action\\Chase\\GetInProximity"
require "State\\NPC\\Action\\Turn\\Face"
require "State\\Crime\\MasterTutorial\\MasterTalk1"
require "State\\Crime\\MasterTutorial\\MasterTalk2"

MasterConversation = Create (State, 
{
	sStateName = "MasterConversation",
})

function MasterConversation:OnEnter ()
	-- Call parent
	State.OnEnter (self)

	-- Execute the state function ShowStatus
	self:ShowStatus ()

	-- Set the character's target
	self.tHost:PushTarget (self.tTarget, true)

	-- Subscribe to custom events generated by the target NPC
	self.nCustomEventID = self:Subscribe (eEventType.AIE_CUSTOM, self.tTarget)

	-- Push the GetInProximity state onto the stack
	self:PushState (Create (GetInProximity, 
	{
			nMovementType = eMovementType.nWalk,
			nRadius = 3,
	}))
end

function MasterConversation:OnExit ()
	-- Call parent
	State.OnExit (self)

	-- Set the character to have no target 
	self.tHost:PopTarget ()
end

-- Define a new member function in the conversation state called 
-- ShowStatus
function MasterConversation:ShowStatus ()
	-- Print the target character's name
	AILib.Emit ("My target is: " .. self.tTarget:RetName ())

	-- Print the name of the character the state belongs to
	AILib.Emit ("My name is: " .. self.tHost:RetName ())

	-- Print the state's name
	AILib.Emit ("My state is: " .. self.sStateName)
end

function MasterConversation:OnActiveStateFinished ()

	-- Trap the GetInProximity state
	if self:IsInState (GetInProximity) then

		-- If this character is set to be the one that talks 
		-- first then go into the Talk state, otherwise just
		-- go into the Face state
		if self.bTalkFirst then
			self:ChangeState (Create (MasterTalk1, {}))
		else
			self:ChangeState (Create (Face, {}))
		end
		return true
	
	-- Trap the Talk state
	elseif self:IsInState (MasterTalk) then

		-- Generate a custom event, which we use to inform the
		-- other NPC that I have finished talking
		self.tHost:NotifyCustomEvent ("TalkFinished")

		-- Go back to the Face state
		self:ChangeState (Create (Face, {}))
		return true

	end

	-- If no state is trapped, the just call parent
	-- This performs the default behaviour of popping the state
	return State.OnActiveStateFinished (self)
end

function MasterConversation:OnEvent (tEvent)

	-- Trap custom events
	if tEvent:HasID (self.nCustomEventID) and

		-- Check that it is the correct custom event
		tEvent:HasCustomEventID ("TalkFinished") then

		-- Go into the Talk state
		if self.bTalkFirst then
			self:ChangeState (Create (MasterTalk1, {}))
		else
			self:ChangeState (Create (MasterTalk2, {}))
		end
		return true

	end

	-- Call parent
	return State.OnEvent (self, tEvent)
end
